# CreateX ecom
Описание:
   Сайт интернет магазина одежды, компания также ведет собственный блог

Изначально макет расчитан на разрешение в 1920px и сверстан под него, при желании можно уменьшить расширение зажав "ctrl" и прокрутив колесо мыши. На мобильных устройствах делать ничего не нужно

## Функциональность без технических подробностей:
- При заходе на страницу сразу активен тестовый аккаунт, в котором срзау имеются готовые заказы, избранные товары, есть оставленные комментарии и товары в корзине
- Имеется возможность регистрации, авторизации, выхода из аккаунта и его удаление, а также возможность менять пароль и восстановить тестовый аккаунт. В связи с особенностью реализации базы данных единовременно может существовать не более 1 аккаунта, для этого и существует возможность восстановить аккаунт (она находиться в всплывающем окне регистрации "create test account" над кнопкой "sign up")
- Можно добавлять товары в избранное
- Возможность менять данные профиля (имя, аддрес, пароль и т.д.)
- Есть "недавно просмотренные" товары
- Есть корзина товаров
- Страница совершения заказов и история заказов в странице профиля, а также страница отслеживания товара
- На определенном разрешении боковые панели прячутся в всплывающие окна, которые открываются по нажатию на кнопку меню. Если вы уменьшаете разрешение на desktop'е, то бывает баг, когда этот процесс не происходит (видимо связано с вычислительной нагрузкой), но при открытии сразу на телефоне меню все в порядке. Помогает перезагрузка страницы (но в случае хостинга на github можно перезагружать только главную страницу, если вы откроете, например, страницу товаров, минуя главную, то она будет недоступно).
- Товары можно фильтровать/сортировать, что происходит с анимацией. Поскольку настоящих товаров мало (около 50), а критериев для фильтрации много, то большое количество фильтров отсеивают все, поскольку таких категорий просто нет и может показаться, что фильтры работают неправильно. Рекомендуется исользовать фильтры цвета и размера
- Постраничное разделение товаров, постов блога
- Разнообразные слайдеры
- Формы валидируются (за исключением форм для имейл рассылок)
- Страница отзывов на товары, статистика по ним, возможность оставить отзыв
- Блог с постами, возможность оставить комментарий


## Стек технологий:
- UI: vue 3 с использованием composition api
- routing: vue-router
- state manager: pinia
- написано на typescript
- сборка с использованием vite
- "База данных": используются json'ы с моковыми данными, которые составляют основу, далее все новые данные в процессе использования сайта (заказы, новые избранные товары, данные аккаунта) добавляются в localStorage с помощью типизированной библиотеки
- Данные: моковые данные я сгенерировал на основе данных из готового шаблона в figma с использованием кастомной библеотеки на node.js для генерации данных из семплов. Т.е. брал семплы из шаблона (например, все виды размеров товара) и с помощью api библеотеки с удобным dsl, по-разному сочетал данные, что позволило сделать разннообразные правдоподобные моковые данные из небольшого набора семплов. Саму библеотеку я похоже случайно удалил:(
- Css: postcss
- Много кастомных решений, которые на мой взгляд интересны


# Функциональность и архитектура приложения:
- Поток данных и api 
   Динамические данные в приложении имеют следующий путь: Компоненты взаимодействуют с моделью в storage, storage знает о слое api - это прослойка, которая фетчит данные, она должна и имеет интерфейс в терминах предметной области (например: api.getProductReviews(productId: number, count?: number) ) и абстрагирует модель и ui от знания url, header'ов и прочих особенностей инфраструктурного слоя http. В настоящем клиент-серверном взаимодействии так и было бы, но в данном случае, чтобы предоставить всю "динамичную" функциональность (делать заказы и чтобы они где-то сохранялись) приходится все устраивать локально, через mock'овые json'ы и localStorage, а чтобы максимально приблизить проект к настоящему, я воссоздал эту цепочку: UI -> Model -> api -> server response - но при этом сэмитировал последнее звено, сделав его локальным (типизированная библиотека-прослойка над localStorage - о ней пойдет речь дальше "кастомные"). В общем, по поведению слой api ведет себя также - он асинхронно возвращает данные, а компоненты и storage изначально пустые и при инициализации они фетчат данные. Все написано таким образом, что для реального приложения достаточно просто подменить имплементацию api, которая будет делать реальные http requrest'ы с тем же интерфейсом и приложение будет работать также

- авторизация: представлена в наборе vue-router, stores/auth (pinia storage), localStorage.
   У каждой страницы, которая требует авторизацию в конфиге vue-router'а в поле meta есть флаг route'а 'isAuthOnly', на основе которого middleware начинает проверять авторизован ли пользователь в stores/auth. При регистрации store/auth (это происходит благодаря кастомну plugin'у для pinia, см. "кастомные решения") сразу же происходит извлечение данных последнего аккаунта из localStorage и используется локальный "endpoint" (утилита api). Если была попытка совершить переход на страницу, которая требует авторизации, будучи неавторизованным, то тот путь, по которому пользователь хотел перейти сохраняется в stores/vueRouter. Это storage, который связывает между собой модель и vue-router - в нем с одной стороны предоставлен api router'а, который могут использовать элементы модели, например, модель может запросить навигацию / открытие popup'а и прочее. С другой стороны этот storage - состояние vue-router'а, где он может хранить путь, по которому пользователь хотел перейти, будучи неавторизованным, а уже после авторизации stores/auth уведомляет router, что пользователь авторизировался и можно автоматически возобновить его навигацию. 
   Этот механизм можно увидеть, например выйдя из account'а, попытаться открыть избранное по иконке с сердечком в header'е, навигация прервется и откроется popup signin, после авторизации пользователь сразу же попадет на ту страницу куда он хотел перейти. Данная фича не работает если уже находится авторизованным на странице, которая требует авторизацию и выйти из аккаунта - выкинет на главную, но при авотризации редиректа не будет.

- UI-kit, иерархия компонентов: 
   Я вдохновлялся Feature Sliced Design'ом, но сделал его проще и этой степени точности для проекта данного масштаба вполне хватило, чтобы понятным однозначным образом распределить ui-компоненты, при этом избежать излишней "бюрократии".
   Если коротко основной принцип FSD заключается в делении на слои, где элемент любого нижестоящего слоя может быть использован вышестоящим, но никак не наоборот. 
   В моем случае иерархия такая: App > Layouts > Pages > Widgets > Features > UI-kit - т.е страницы исплользуют widget'ы (большие самодостаточные блоки, например, блок рекламы, фильтры, галерею товаров, слайдер с конкретным наполением), они используют features и ui-kit, features могут испльзовать ui-kit.
   UI-kit представлен глобальными ui-компонентами - кнопками, ссылками, элементами форм, спойлерами и т.д - это ничего не знает о предметной области
   Features - это маленькие элементы, которые уже связаны с предметной областью, но не являются самодостаточными элементами UI - своего рода ui-kit, сопряженный с предметной областью (например, иконка любимых товаров в header'е сайта)
   Widget'ы - в идеале самодостаточные блоки, которые можно пихать в любую страницу, в любое окружение и все будет работать одинаково.

- адаптив и верстка:
   Адаптив я старался сделать по-максимуму используя responsive структуры, которые не требуют никаких media/container query запросов и при любом контенте и расширении адаптируются самостоятельно. Так получалось не всегда. Подробнее рассказывает в "кастомных решениях".

- Перечень пользовательсих фич: 
   авторизация, управление профилем (пользовательские данные, смена пароля, избранное, недавно просмотренные товары, история заказов, отзывы пользователя), страница продуктов и различные фильтры и сортировки с анимацией, поиск товаров по названию, деление этих карточек товаров по страницам, где можно настраивать количество товаров на странице; блог, страницы конкртеных постов с динамическим содержанием - используется особый dsl - по сути, это json с контентом + метаинформация о том, что какой Dom элемент (tag) наполнить этим контентом, а дальше специальная функция на основе этих данных генерировала Vnode'у, которуя я вставлял на страницу - т.е. есть набор доступных элементов из которых может состоять статья блога, а вот из каких конкретно tag'ов она состоит, с каким контентом и в какой очередности они расположены и определяется json'ом с информацией о контенте. Корзина товаров, страница подтверждения заказа, формы оплаты и валидация (практически все формы валидируются, кроме различных форм для email рассылки), страница отслеживания заказа из истории заказов, bread crumbs (хлебные крошки)

- Подход к фичам и переиспользование 
   Всю функциональность я стралался сделать переиспользуемой, которая просто выполняет какую-то часть работы и передает результат дальше по цепочке, а конкретные решения на странице складывались из композии простоых элементов. Возвращаясь к примеру с карточками товара и пагинацией, моей целью было сделать так, чтобы функциональность могла работать с разным сущностями и ui-component'ами. Например пагинация представлена хуком composables/usePagination, который прнимает количество товаров, лимит и текущую страницу и возвращает индексы из общего массива товаров, которые соответствуют текущей странице - т.е. можно "пагинировать" массивы любых данных, сам ui-component который предоставляет интерфейс для управления пагинацией также не связан с конкретными данными - только количество страниц и текущая. 

# Кастомные решения (todo):
- Typed vue-router
- AppLink, VueRouterExtension, propsParser
- pinia plugin: onRegister
- pinia plugin: stateCacher
- pinia plugin: exportImportState
- adaptive size, functions/rl
- postCss functions
- composables/useLocalStorage
- composables/usePopupManager
- composables/useMobileSidebar

