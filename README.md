# CreateX ecom
Описание:
   Сайт интернет магазина одежды, компания также ведет собственный блог

Если коротко:
- Сверстал desktop по готовому макету и доработал адаптив вплоть до мобильной версии, которой в макете не было
- Исходя из макета продумал, какой функционал должен был быть на сайте и реализовал (авторизация, совершение заказа, комментарии и т.д.)
- Сделал "базу данных" на клиенте, чтобы чтобы приложение выглядело правдоподобно и без бекенда
- Сделал тестовый аккаунт, чтобы вы могли зайти на сайт от лица постоянного пользователя и увидеть сайт в полной мере
- В приложении отсутствует кроссбраузерность. Я не стал отказываться от современных возможностей для построения гибких CSS структур, впрочем совсем новые и экспериментальные фичи я тоже не использовал
- Изначально макет расчитан на разрешение в 1920px и сверстан под него, при желании можно уменьшить расширение зажав "ctrl" и прокрутив колесо мыши. На мобильных устройствах делать ничего не нужно

## Функциональность без технических подробностей:
- При заходе на страницу сразу активен тестовый аккаунт, в котором срзау имеются готовые заказы, избранные товары, есть оставленные комментарии и товары в корзине
- Имеется возможность регистрации, авторизации, выхода из аккаунта и его удаление, а также возможность менять пароль и восстановить тестовый аккаунт. В связи с особенностью реализации базы данных единовременно может существовать не более 1 аккаунта, для этого и существует возможность восстановить тестовый аккаунт (она находиться в всплывающем окне регистрации "create test account" над кнопкой "sign up")
- Можно добавлять товары в избранное
- Возможность менять данные профиля (имя, аддрес, пароль и т.д.)
- Есть "недавно просмотренные" товары
- Есть корзина товаров
- Страница совершения заказов и история заказов в странице профиля, а также страница отслеживания товара
- На определенном разрешении боковые панели прячутся в всплывающие окна, которые открываются по нажатию на кнопку меню. Если вы уменьшаете разрешение на desktop'е, то бывает баг, когда этот процесс не происходит (видимо связано с вычислительной нагрузкой), но при открытии сразу на телефоне меню все в порядке. Помогает перезагрузка страницы (но в случае хостинга на github pages можно перезагружать только главную страницу, если вы откроете, например, страницу товаров, минуя главную, то она будет недоступна).
- Товары можно фильтровать/сортировать, что происходит с анимацией. Поскольку настоящих товаров мало (около 50), а критериев для фильтрации много, то большое количество фильтров отсеивают все, поскольку таких категорий просто нет и может показаться, что фильтры работают неправильно. Рекомендуется исользовать фильтры цвета и размера
- Постраничное разделение товаров, постов блога
- Разнообразные слайдеры, всплывающие окна
- Формы валидируются (за исключением форм для имейл рассылок)
- Страница отзывов на товары, статистика по ним, возможность оставить отзыв
- Блог с постами, возможность оставить комментарий
- Поиск товаров/постов по названию


## Стек технологий:
- UI: vue 3 с использованием composition api
- routing: vue-router
- state manager: pinia
- написано на typescript
- сборка с использованием vite
- "База данных": используются json'ы с моковыми данными, которые составляют основу, далее все новые данные в процессе использования сайта (заказы, новые избранные товары, данные аккаунта) добавляются в localStorage с помощью типизированной библиотеки
- Данные: моковые данные я сгенерировал на основе данных из готового шаблона в figma с использованием кастомной библеотеки на node.js для генерации данных из семплов. Т.е. брал семплы из шаблона (например, все виды размеров товара) и с помощью api библеотеки с удобным dsl, по-разному сочетал данные, что позволило сделать разннообразные правдоподобные моковые данные из небольшого набора семплов. Саму библеотеку я похоже случайно удалил:(
- Css: postcss
- Много кастомных решений, которые на мой взгляд интересны


# Функциональность и архитектура приложения:
- Поток данных и api 
   Динамические данные в приложении имеют следующий путь: Компоненты взаимодействуют с моделью в storage, storage знает о слое api - это прослойка, которая фетчит данные, она должна и имеет интерфейс в терминах предметной области (например: api.getProductReviews(productId: number, count?: number) ) и абстрагирует модель и ui от знания url, header'ов и прочих особенностей инфраструктурного слоя http. В настоящем клиент-серверном взаимодействии так и было бы, но в данном случае, чтобы предоставить всю "динамичную" функциональность (делать заказы и чтобы они где-то сохранялись) приходится все устраивать локально, через mock'овые json'ы и localStorage, а чтобы максимально приблизить проект к настоящему, я воссоздал эту цепочку: UI -> Model -> api -> server response - но при этом сэмитировал последнее звено, сделав его локальным (типизированная библиотека-прослойка над localStorage - о ней пойдет речь дальше "кастомные решения"). В общем, по поведению слой api ведет себя также - он асинхронно возвращает данные, а компоненты и storage изначально пустые и при инициализации они фетчат данные. Все написано таким образом, что для реального приложения достаточно просто подменить имплементацию api, которая будет делать реальные http requrest'ы с тем же интерфейсом и приложение будет работать также

- авторизация: представлена в наборе vue-router, stores/auth (pinia storage), localStorage.
   У каждой страницы, которая требует авторизацию в конфиге vue-router'а в поле meta есть флаг route'а 'isAuthOnly', на основе которого middleware начинает проверять авторизован ли пользователь в моделе (stores/auth). При регистрации store/auth (это происходит благодаря кастомну plugin'у для pinia, см. "кастомные решения") сразу же происходит извлечение данных последнего аккаунта из localStorage и используется локальный "endpoint" (утилита api). Если была попытка совершить переход на страницу, которая требует авторизации, будучи неавторизованным, то тот путь, по которому пользователь хотел перейти сохраняется в stores/vueRouter. Это storage, который связывает между собой модель и vue-router - в нем с одной стороны предоставлен api router'а, который могут использовать элементы модели, например, модель может запросить навигацию / открытие popup'а и прочее. С другой стороны этот storage - состояние vue-router'а, где он может хранить путь, по которому пользователь хотел перейти, будучи неавторизованным, а уже после авторизации stores/auth уведомляет router, что пользователь авторизировался и можно автоматически возобновить его навигацию. 
   Этот механизм можно увидеть, например выйдя из account'а, попытаться открыть избранное по иконке с сердечком в header'е, навигация прервется и откроется popup signin, после авторизации пользователь сразу же попадет на ту страницу куда он хотел перейти (избранное). Данная фича не работает если уже находится авторизованным на странице, которая требует авторизацию и выйти из аккаунта - выкинет на главную, но при авотризации редиректа не будет.

- UI-kit, иерархия компонентов: 
   Я вдохновлялся Feature Sliced Design'ом, но сделал его проще и этой степени точности для проекта данного масштаба вполне хватило, чтобы понятным однозначным образом распределить ui-компоненты, при этом избежать излишней "бюрократии".
   Если коротко основной принцип FSD заключается в делении на слои, где элемент любого нижестоящего слоя может быть использован вышестоящим, но никак не наоборот. 
   В моем случае иерархия такая: App > Layouts > Pages > Widgets > Features > UI-kit - т.е страницы исплользуют widget'ы (большие самодостаточные блоки, например, блок рекламы, фильтры, галерею товаров, слайдер с конкретным наполением), они используют features и ui-kit, features могут испльзовать ui-kit.
   UI-kit представлен глобальными ui-компонентами - кнопками, ссылками, элементами форм, спойлерами и т.д - они ничего не знают о предметной области.
   Features - это маленькие элементы, которые уже связаны с предметной областью, но не являются самодостаточными элементами UI - своего рода ui-kit, сопряженный с предметной областью (например, иконка любимых товаров с ссылкой в header'е сайта)
   Widget'ы - в идеале самодостаточные блоки, которые можно вставлять в любую страницу, в любое окружение и все будет работать одинаково.

- адаптив и верстка:
   Адаптив я старался сделать по-максимуму используя responsive структуры, которые не требуют никаких media/container query запросов и при любом контенте и расширении адаптируются самостоятельно наилучшим образом. Так получалось не всегда. Подробнее рассказывает в "кастомных решениях".
   Использовал UI-kit, который сверстал по макету. Использовал postcss и различные плагины.

- Перечень пользовательсих фич: 
   Авторизация, управление профилем (пользовательские данные, смена пароля, избранное, недавно просмотренные товары, история заказов, отзывы пользователя), страница продуктов и различные фильтры и сортировки с анимацией, поиск товаров/постов по названию, деление этих карточек товаров/постов по страницам, где можно настраивать количество товаров на странице. Блог, страницы конкртеных постов с динамическим содержанием - используется особый dsl - по сути, это json с контентом + метаинформация о том, что какой Dom элемент (tag) наполнить этим контентом, а дальше специальная функция на основе этих данных генерировала Vnode'у, которую я вставлял на страницу - т.е. есть набор доступных элементов из которых может состоять статья блога, а вот из каких конкретно tag'ов она состоит, с каким контентом и в какой очередности они расположены и определяется json'ом с информацией о контенте. Корзина товаров, страница оформления заказа, формы оплаты и валидация (практически все формы валидируются, кроме различных форм для email рассылки), страница отслеживания заказа из истории заказов, bread crumbs (хлебные крошки)

- Подход к фичам и переиспользование
   Всю функциональность я стралался сделать переиспользуемой, которая просто выполняет какую-то часть работы и передает результат дальше по цепочке, а конкретные решения на странице складывались из композии простых элементов, которые только предоставляют функциональность. 
   Более того, делая какую-то сущность, котороая предоставляет функциональность и api для нее, я старался прокинуть этот api в разные слои приложения, чтобы из разных мест можно было управлять поведением.

   Пример: есть глобальный компонент PopupManager.vue, который централизовано управлял логикой работы с модальными окнами - открыть/закрыть/спрятать/показать, настроить конкретный вариант отображения. Он работает в UI слое и по дефолту для модели недоступен. Создавая инстанс компонента он делает свой api публичным, предоставляя его в composables/usePopupManager, которая позволяет уже позволяет использовать его в других компонентах уже независимо от иерархии компонентов, в любом store, vue-router'е, главное, чтобы компонент был отрендерен до его использования - механизм похож на инъекцию зависимосей в pinia. Также я предоставлял этот api во все участки, где он мог бы органически понадобиться - примиксовывал во vue-router (router.openPopup(),... ), поскольку это часть навигации; в model (stores/vueRouter), чтобы на основе данных программным способом можно было управлять интерфейсом и другие store'ы не были завязаны на UI, а только обращались к специализированной части модели, которая работает с отображением и скрывает всю сложность и имплементацию.


# Кастомные решения (todo):
- Typed vue-router:
   Сделал библиотеку на typescript, которая принмает конкретный конфиг route'ов в приложении, парсит их и на выходе предоставляет весь список страниц, компоненты, которые они рендерят и пропсы, которые для них нужны. Далее все эти типы автоматически подхватывается типизированными обертками над vue-router (AppLink.vue вместо RouterLink.vue, router.$navigate() вместо router.push и compsables/useNavigate() )
   Все что нужно для использования это в router/index.ts просто сохранить конфиг route'ов as const и экспортировать его. 
- modifiedTo() + propsParser:
   Это runtime функциональность для vue-router'а. Позволяет прокидывать непримитивные параметры в to.params, которые сериализуются в json (как через AppLink, так и router.$navigate). Далее в конфиге route'ов нужно предоставить функцию-парсер пропсов.
   Типизацию и runtime функциональность подключает vue plugin (plugins/vueRouterExtension)
- pinia plugin: onRegister
   Это аналог lifecycle hook'а vue-компонентов onMounted(). При первом вызове useFooStore() store регистрируется в pinia и для него отрабатывают все pinia plugin'ы. В одном из них при наличиии fooStore.onRegister() - она вызывается. Это отличное место для api запросов, или извлечения данных из localStorage. Можно для большей предсказуемости реализовать и через кастомные опции с поддержкой типизации 
- pinia plugin: stateCacher (не используется)
   Плагин, при регистрации store'а и наличии флага в опциях store'а извлекает из localStorage состояние прошлой сессии и при любых изменениях обновляет его. 
- pinia plugin: exportImportState (не используется)
   Инъектирует в каждый store 2 функции "exportState()", "importState()" - первая сериализует state и скачивает его на устройство пользователя через динамическую ссылку - второе производит обратное действие при помощи динамического <input type="file">
- adaptive size, functions/rl
   postcss утилита в виде js-функции, которая позволяет делать динамические величины пропорциональные текущему viewport'у на чистом CSS. До этого реализовывал в виде scss mixin'а. 
   Работает на функции clamp, и линейном уравнеии px = f(vw) в качестве динамической части
   Как используется:
      Передаем значения pxMin, pxMax, vpMin, vpMax (vpMin, vpMax - опциональны и задаются переменным в макете, например 320 и 1440)
      font-size: rl(8, 10, 320, 1440) // rl === responsiveLeng
      Означает, что при viewport <= 320px font-size = 8px, 
      при viewport от 320px до 1440px будет плавно расти от 8px до 10px
      при viewport >= 1440px font-size = 10px

      Соответственно при переходе к мобильному расширению у нас может на 20% уменьшиться значение 1rem и все шрифты, карточки, оступы и прочее, что написано на rem будет уменьшино на 20% без единого медиа запроса.
- postCss functions
   Можно писать js-функции, которые отрабатывают в node'е при сборке и позволяют писать удобный синтаксис для расчета сложных значений в виде использования функций
- composables/useLocalStorage
   Обертка над localStorage, которая предоставляет публичный расширяемый tyepscript interface, в котором провайдеры должны зарегистрировать записи в localStorage - забронировать ключ в localStorage и предоставить тип значений, которые будут храниться по этому ключу. После этого можно использовать api useLocalStorage, в котором появляет возможность выбора этого ключа. 
   Инструмент позволяет избежать коллизий имен в localStorage, дает автокомплит, проверяет тип данных при записи и извлечении данных, проводит де/сериализацию
- composables/usePopupManager
   Уже описывался в примере "Подход к фичам и переиспользование". 
- composables/useMobileSidebar
   Позволяет по опрделенному условию (например, текущему viewport'у) прятать часть содержимого в мобильный sidebar в модальном окне, которое открывается по бургеру 

